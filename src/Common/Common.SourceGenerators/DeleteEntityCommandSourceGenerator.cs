using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Common.SourceGenerators;

[Generator]
public class DeleteEntityCommandSourceGenerator : IIncrementalGenerator
{
    private const string AuditableEntityInterfaceName = "IAuditableEntity";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Step 1: Get the module name
        var moduleNameProvider = context
            .CompilationProvider
            .Select((compilation, _) => GetModuleName(compilation.AssemblyName!));

        // Step 2: Get the domain project name
        var domainProjectNameProvider = moduleNameProvider
            .Select((moduleName, _) => $"{moduleName}.Domain");

        // Step 3: Find the domain assembly symbol
        var domainAssemblyProvider = context
            .CompilationProvider
            .Combine(domainProjectNameProvider)
            .Select((pair, _) =>
            {
                var (compilation, domainProjectName) = pair;
                return compilation
                        .SourceModule
                        .ReferencedAssemblySymbols
                        .SingleOrDefault(assembly => string.Equals(assembly.Name, domainProjectName, StringComparison.Ordinal));
            });

        // Step 4: Generate the endpoints for each entity implementing IAuditableEntity
        var endpointSourceProvider = domainAssemblyProvider
            .SelectMany((domainAssemblySymbol, _) => GetAuditableEntities(domainAssemblySymbol?.GlobalNamespace))
            .Combine(moduleNameProvider)
            .Select((pair, _) => GenerateDeleteCommandCode(pair.Left.namespaceName, pair.Right, pair.Left.className));

        // Step 5: Add the source to the compilation
        context.RegisterSourceOutput(endpointSourceProvider, (context, source) =>
        {
            context.AddSource($"{source.ClassName}_DeleteCommand.g.cs", SourceText.From(source.SourceCode, Encoding.UTF8));
        });

    }

    private static IEnumerable<(string namespaceName, string className, string sourceCode)> GetAuditableEntities(INamespaceSymbol? rootNs)
    {
        if (rootNs is not null)
        {
            var stack = new Stack<INamespaceSymbol>();
            stack.Push(rootNs);

            while (stack.Count > 0)
            {
                foreach (var member in stack.Pop().GetMembers())
                {
                    if (member is INamespaceSymbol namespaceSymbol)
                    {
                        stack.Push(namespaceSymbol);
                    }
                    else if (member is INamedTypeSymbol namedTypeSymbol && ImplementsIAuditableEntity(namedTypeSymbol))
                    {
                        var namespaceName = namedTypeSymbol.ContainingNamespace.ToDisplayString();
                        var className = namedTypeSymbol.Name;
                        var (SourceCode, ClassName) = GenerateDeleteCommandCode(namespaceName, string.Empty, className);
                        yield return (namespaceName, ClassName, SourceCode);
                    }
                }
            }
        }
    }

    private static bool ImplementsIAuditableEntity(INamedTypeSymbol namedTypeSymbol)
        => namedTypeSymbol
            .AllInterfaces
            .Any(i => i.Name.Contains(AuditableEntityInterfaceName));

    private static string GetModuleName(string assemblyName)
    {
        // Assuming the assembly name follows the pattern {ModuleName}.Application
        var parts = assemblyName.Split('.');
        if (parts.Length > 1 && parts[1] == "Application")
        {
            return parts[0];
        }

        throw new InvalidOperationException("Invalid assembly name");
    }

#pragma warning disable S1172 // Unused method parameters should be removed
#pragma warning disable IDE0060 // Remove unused parameter
    private static (string SourceCode, string ClassName) GenerateDeleteCommandCode(string namespaceName, string moduleName, string className)
#pragma warning restore IDE0060 // Remove unused parameter
#pragma warning restore S1172 // Unused method parameters should be removed
    {
        var pluralClassName = Pluralize(className);
        var sourceCode = $@"
// WARNING: Auto-Generated by Source Generator.

using Common.Domain.ResultMonad;
using Common.Application.Persistence;
using Common.Application.CQS;
using Microsoft.EntityFrameworkCore;
using {moduleName}.Application.Persistence;
using System.Linq.Expressions;
using Common.Application.Validation;
using FluentValidation;
using Microsoft.Extensions.Localization;
using {namespaceName};
using Common.Domain.StronglyTypedIds;

namespace {moduleName}.Application.{pluralClassName}.Features.Delete;

#nullable enable

public sealed record Delete{className}Command : ICommand
{{
    public Delete{className}Command({className}Id id)
    {{
        Id = id;
    }}

    public {className}Id Id {{ get; private set; }}

    /// <summary>
    /// To prevent somebody from updating a {className} that does not belong to them.
    /// </summary>
    public Expression<Func<{className}, bool>>? EnsureOwnership {{ get; init; }}
}}

public class Delete{className}CommandValidator : CustomValidator<Delete{className}Command>
{{
    public Delete{className}CommandValidator(IStringLocalizer<Delete{className}CommandValidator> localizer)
    {{
        RuleFor(x => x.Id)
            .NotEmpty()
                .WithMessage(localizer[""{pluralClassName}.Delete.Id.NotEmpty""]);
    }}
}}

public sealed class Delete{className}CommandHandler : ICommandHandler<Delete{className}Command>
{{
    private readonly I{moduleName}DbContext _dbContext;

    public Delete{className}CommandHandler(I{moduleName}DbContext dbContext) => _dbContext = dbContext;

    public async Task<Result> Handle(Delete{className}Command command, CancellationToken cancellationToken)
        => await _dbContext
            .{pluralClassName}
            .TagWith(nameof(Delete{className}Command), command.Id)
            .WhereIf(command.EnsureOwnership!, condition: command.EnsureOwnership is not null)
            .SingleAsResultAsync(cancellationToken)
            .TapAsync({LowerFirstLetter(className)} => _dbContext.{pluralClassName}.Remove({LowerFirstLetter(className)}))
            .TapAsync(async _ => await _dbContext.SaveChangesAsync(cancellationToken));
}}
#nullable restore
";
        return (sourceCode, className);
    }

    private static string Pluralize(string word)
    {
        if (word.EndsWith("y", StringComparison.OrdinalIgnoreCase))
        {
            return $"{word.Substring(0, word.Length - 1)}ies";
        }

        if (word.EndsWith("s", StringComparison.OrdinalIgnoreCase))
        {
            return $"{word}es";
        }

        return $"{word}s";
    }

    private static string LowerFirstLetter(string word)
    {
        if (word.Length == 0)
        {
            return string.Empty;
        }

        return $"{char.ToLowerInvariant(word[0])}{word.Substring(1)}";
    }
}
